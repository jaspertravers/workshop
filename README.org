#+TITLE: Workshop
#+AUTHOR: Jasper Travers
** Design
This "Workshop" project is the culmination of 3+ years of active interest in programming tools which has been a slowly growing interest of mine since I started programming for the first time in the experimental bridge education program SPIS the summer before my freshman year at UCSD.

The beginning of a deeper engagement with my digital experience was using linux as my daily driver and eventually finding tiling window managers, and took on it's first manifestation with a project in the Interaction Design class taught by Philip Guo. In my second year, after 4 core programming classes (about roughly 120hrs of lecture and 480hrs of lab work) as motivation, my partners and I built a live coding teaching tool for simultaneously allowing the instructor to broadcast code, whether by live coding or prepared files, and allowing the student to edit and probe that code in real time locally without losing the context of the lesson. This was achieved in a structured design process: needfinding, experience design, paper prototying, mockups, implementation, user studies, A/B testing. The solution we came up with took on the novel-to-us form of having more than one editor on the screen at once. This wasn't multiple tabs with multiple terminals in an IDE, it was two separate contexts with two separate execution controls. The instructor broadcast the lesson context and the student manipulated their own local space for reflecting on the lesson. It was validating, in the year or so following our project, to see Atom and VSCode each launch remote pair programming plugins on the same day.

While we succeeded in deploying and having a fully functional base set of interactions on the site credit to some outstanding effort by John, the project was quickly taken offline but inspired me to continue thinking and working on programming environments. The next project taking the form of a creative coding environment which was a direct result of the success we saw with the multiple editor affordances of this first project.

Spending so much time in the design lab let me steep in the creative process going on in the social sciences side of the lab which led me to explore parallel design in coding. As these things always seem to go, it was only after months of hacking away with a few friends did I realize how relevant the work going on around me at UCSD was to this exploration. Scott Klemmer and Steven Dow have a history of awesome experiments on Parallel Design and multi-modal software development and I only wish I had more time to reflect and build upon what I learned from their history. Adam Rule, as a small part of his larger work, released a code organizational feature for Jupyter which helped me realize the space of possibilities for designing this parallel functionality. Jim Hollan has Pad++, but we're not there yet.

The second iteration of the programming environment project was a creative coding environment laid out as a more compact computational notebook. We built the same concept of a column of cells, but with canvas output in the same block. Then the fun part came with the parallel design cell manipulations. It really came down to a single button of duplicating an existing cell to flesh out almost the same, but different ideas during the creative coding process. There are an endless set of features I want to add to that work including so many quality of life improvements, but the feel of working on an open ended project affording just that workflow alone was great. My partner and I took this project into Scott Klemmer's Interaction Design Research class and fleshed it out and turned it into a pilot study where we had hilariously bad results, but an altogether rewarding learning experience. Note to self: trying to even aproach a (first!) research project of a technical creative system in 10 weeks is much, much too short a time.

"Workshop" is the third iteration of this theme. Throughout the various (badly named) commits are a variety of explorations of infinite canvas end user programming. Taking Ward Cunningham's realization about the Card as the unit of the wiki and Ivan Sutherland's Object Oriented Sketchpad as inspiration this was an experiment of creating a nestable card to carry any and all digital content. The card is manipulatable with the mouse: creating, resizing, selecting, deleting. The "primitives" that the system "ships with" for card content are a prose and code editor from Marijn Haverbeke, ProseMirror and CodeMirror as well as a canvas and a (still working on it) object browser. The environment is then about creating new card types and filling them with whatever digital content the user likes. Taking advantage of the browser as the ultimate platform. In this environment I have created gui controls for system interactions and mocked up a canvas based featureful PDF reader in about two minutes. I can feel that the move from simply mocking up a UI with cards to assigning those cards listeners and building a cohesive custom GUI on the fly is just on the edge of my ability. Iframes with editors with canvas with dynamic content and persistent or temporary on-the-fly end user programmed interactions are just so fun.



This is a fun story to tell and still with many holes and poor writing, but I'll work on it.

- Jasper

Communication, computation, work.
(todo: compile the disparate design docs)

---

What follows is a short time working-dashboard I used during development, it is without explanation and meant to be read and used in emacs org mode. It does contain the build setup for the project and links to dependencies. You can run this by cloning the repo and running.
#+BEGIN_SRC javascript
npm install
npm run dev
#+END_SRC

Two older versions are online at these links. They lack instructions and content. This repo will be deployed soon with at least some small instructions.
https://github.com/jaspertravers/workshop
https://github.com/jaspertravers/workshop2


** Dependencies
- https://www.stopify.org/
- https://codemirror.net/
- https://prosemirror.net/
- https://rollupjs.org/guide/en/


* Notes
** Developtment
*** Development log
**** npm/build
#+BEGIN_SRC sh
npm init

npm install @stopify/stopify
npm install @codemirror/next # this will change on v1.0.0 release

npm install prosemirror-model
npm install prosemirror-state
npm install prosemirror-view
npm install prosemirror-transform
# going to need a few more prosmirror modules; yes these can be space separated

npm install rollup --global

mkdir src public
touch src/main.js
touch rollup.config.js

npm install rollup --save-dev # being thorough about building
# building: npm run build

Need a bundler: either rollup, parcel, webpack, snowpack

# to catch up with rollup-starter-app
npm install serve --save-dev
npm install @rollup/plugin-commonjs --save-dev
npm install @rollup/plugin-node-resolve --save-dev
npm install rollup-plugin-terser --save-dev
npm install npm-run-all --save-dev

npm install webpack --save-dev # trying to tame warnings

npm install --save-dev @rollup/plugin-json
npm install --save-dev rollup-plugin-node-polyfills
#+END_SRC

Babel Issues:
#+BEGIN_SRC sh
npm install @rollup/plugin-babel --save-dev
npm install @babel/core --save-dev
npm install ajv --save-dev

npm install babel-loader @babel/core --save-dev

#+END_SRC

I'm going to give up on importing stopify and will instead include the bundle. Uninstalling myriad npm packages I used to try to fix the problem.

#+BEGIN_SRC
npm uninstall babel-loader @babel/core @rollup/plugin-babel ajv
#+END_SRC

Copying bundle into place and including in ~public/index.html~, I suppose I could very well remove ~@stopify/stopify~ but I'll leave it for now for followup investigation.

~npm run build~ script set in ~package.json~

#+BEGIN_SRC sh
npm install --save-dev rollup-plugin-serve
npm install --save-dev rollup-plugin-livereload
#+END_SRC
editing config file to match

#+BEGIN_SRC sh
npm install prosemirror-keymap prosemirror-history prosemirror-commands prosemirror-dropcursor prosemirror-gapcursor prosemirror-menu prosemirror-inputrules prosemirror-schema-list prosemirror-schema-basic

npm install prosemirror-example-setup
#+END_SRC

**** Editors
backspace on empty editor throws "RangeError"

~view.state.doc.toString()~
to get string in editor for stopify

time for prosemirror
taken most things from ~prosemirror-example-setup~ and the basic editor example.
- https://prosemirror.net/examples/basic/
**** Block

| Block |          |        |
|-------+----------+--------|
|       | content  |        |
|       | position |        |
|       |          | top    |
|       |          | left   |
|       |          | width  |
|       |          | height |
|       |          |        |

Block will be a div that has a child div to fill with content.

**** Dev Tools
https://www.npmjs.com/package/chrome-devtools-frontend

npm install chrome-devtools-frontend

https://martinfowler.com/articles/micro-frontends.html

https://chrome-devtools-frontend.appspot.com/serve_file/@9c7912d3335c02d62f63be2749d84b2d0b788982/devtools_app.html
https://github.com/auchenberg/devtools-remote/issues/5

Dev Tools links that "work"
https://chrome-devtools-frontend.appspot.com/serve_file/@9c7912d3335c02d62f63be2749d84b2d0b788982/devtools_app.html
https://chrome-devtools-frontend.appspot.com/serve_file/@9c7912d3335c02d62f63be2749d84b2d0b788982/devtools_app.html
https://chrome-devtools-frontend.appspot.com/serve_file/@010ddcfda246975d194964ccf20038ebbdec6084/audits2_worker/audits2_worker_module.js
*** Links
- https://git-scm.com/book/
- https://rollupjs.org/guide/en/
- https://github.com/rollup/rollup-starter-app
- https://rollupjs.org/guide/en/#quick-start

** Base
The "thing" this all sits on. Where the components go.

*** Links

** Codemirror
Code editor.

*** Links
- https://codemirror.net/6/docs/guide/
- https://github.com/codemirror/codemirror.next/

** Execution Control
Towards a live sandbox.

*** Links
- https://www.stopify.org/
- https://stopify.readthedocs.io/en/latest/quickstart.html

** Prosemirror
Content editor.

*** Markdown
Prosemirror does not have a package out of the box that supports live markdown editing. It does, however, support some markdown features. Specifically, the ones where symbols start at the beginning of the line. Headers (#), lists (-), ordered lists (1.), code fences (```), and blockquotes (>).

These are the "easier" set of input rules to transform as they all require starting at the beginning of the line. Markdown styles within a line, such as bold, italics, underline, strikethrough, and link styling require relatively more complicated regex to describe and have many edge cases when combined.

These are setup under the =inputrules= module.

I wonder if it would be easy to have a markdown-code view within a leaf and rendered outside of the current focus.

The key here is going to be ~rulebuilders.js~ in =prosemirror-inputrules=

We have a relatively broken markdown input set in ~inputrules.js~. For now I'll leave it as it, it'll take a deep dive to figure out how to fix it.

- Backspacing into a marked section sets the mark to the current cursor.
- Both styles cannot be set.
- I think there is a better way to do this within nodes and using the ~prosemirror-markdown~ package.

Might be able to figure out what gitlab did to make their editor work.


https://prosemirror.net/docs/ref/#inputrules

*** Links
- https://prosemirror.net/docs/guide/
- https://prosemirror.net/docs/ref/#inputrules
- https://gitlab.com/gitlab-org/gitlab-foss/-/tree/master/app/assets/javascripts/behaviors/markdown
- https://github.com/ueberdosis/tiptap/tree/master/packages/tiptap-extensions
- https://github.com/ueberdosis/tiptap

There's a big opportunity to make this work correctly. Searching the tiptap issue list for "mark" yielded multiple open issues regarding markdown ergonomics.

** Console
debug/repl style output; printing from code

*** Links
- https://eloquentjavascript.net/code/
- https://github.com/marijnh/Eloquent-JavaScript/tree/master/html/js
-

** Canvas/SVG
creative coding output

*** Links
- http://bucephalus.org/text/CanvasHandbook/CanvasHandbook.html

** Explorations
Tech to check out; capabilities to explore

- git; this repo
- *mirror nodes for variolite local versioning. This is exactly the architecture these systems are built to explore.
- Write a ~prosemirror-full-markdown~ package... maybe.


*** Links
- https://github.com/yjs/yjs
- https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API
- https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe
- https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps

** Inspirations
Yes, again...
As always, incomplete.

*** Links
- https://github.com/hundredrabbits/Ronin
- https://github.com/damelang/nile
- http://worrydream.com/refs/Sutherland-Sketchpad.pdf
- https://paper.dropbox.com/doc/Stamper-An-Artboard-Oriented-Programming-Environment--A4V0v1SHSKMwJb74PRF4eBnPAg-QXtfMXshBFBNCu6iCtx2J
- https://makespace.fun/
- http://www.joelotter.com/kajero/

* Footer
Note: Github does not render ~.org~ files entirely correctly. This file is edited and read in emacs with org mode.

* Flat

Every editor hooked up to local storage.
Every editor named and attached to a browser.
Every editor tagged.
See tiddlywiki tags and filters.

execution order and setting of that order will be a fascinating problem

#+BEGIN_SRC js
var script = document.createElement('script');
script.type = 'text/javascript'; //could this be module?
script.src = 'script.js'; //can be cdn source
document.head.appendChild(script);
#+END_SRC

| Boot | Viewport | Library | Workspace |

Boot: Initializes Primitives
- cm, pm, console, card, stopify

Initializes visual interface via Viewport

Viewport: Initializes Visual Interface
- tabs bar

Storage:

#+BEGIN_SRC
workspace
  [space]
    [card]
      content

content: cm | pm | console | canvas | iframe | webrtc
#+END_SRC
